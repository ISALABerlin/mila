---
title: "Interpolation"
author: Freie Universität Berlin -- M.Sc. Landschaftsarchäologie <br> Modellieren in der Landschaftsarchäologie <br> Dr. Daniel Knitter (CAU Kiel) <br>
date: WS 2016/2017
bibliography: VS_Modellierung_Literature.bib
csl: harvard1.csl
output:
  ioslides_presentation:
    toc: true
    highlight: pygments
    widescreen: true
    smaller: true
---

# Prerequisites

## setwd, library, data, cleaning

```{r echo=FALSE}
## this is here, so that knitr allows to change the working directory
knitr::opts_knit$set(root.dir = "..")
```

```{r eval=FALSE}
setwd("YOUR-PATH")
```	

```{r load-data, message=FALSE}
raw_data <- read.table(file = "data/FS_UTM.csv",
                       header = TRUE,
                       sep = ";",
                       stringsAsFactors = FALSE,
                       quote = "")

## check for issues/problems
## str(raw_data)
## apply(X=raw_data[,4:20], MARGIN = 2, FUN=function(x){x[x>1]})
raw_data$settlement[raw_data$settlement > 1] <- 1

library(sp)
sites <- raw_data[(raw_data$settlement == 1 & raw_data$iron.age == 1),]
coordinates(sites) <- ~xUTM+yUTM
proj4string(sites) <- CRS("+init=epsg:32634")
```

## Create Point Pattern dataset

```{r message=FALSE}
library(spatstat)
                                                    
sites_pp <- ppp(x = sites@coords[,1],
                y = sites@coords[,2],
                window = owin(xrange = c(min(sites@coords[,1]),
                                         max(sites@coords[,1])
                                         ),
                              yrange = c(min(sites@coords[,2]),
                                         max(sites@coords[,2])
                                         )
                              )
                )
unitname(sites_pp) <- c("meter", "meters")

anyDuplicated(sites_pp)
sites_pp <- sites_pp[duplicated(sites_pp)==FALSE]
anyDuplicated(sites_pp)
#plot(sites_pp)
```

## Caluclate density using graph methods

Distance based density using "largest empty circle"

Idea: calculate the centres of the largest empty circles -- corresponds to the edges of the Voronoi graph

```{r}
library(tripack)

sites_vor <- voronoi.mosaic(x = sites_pp$x,
                            y = sites_pp$y,
                            duplicate = "remove"
                            ) 
rad <- sites_vor$radius
lec <- SpatialPointsDataFrame(coords = cbind(sites_vor$x, sites_vor$y),
                              data = as.data.frame(rad), # length of edge
                              proj4string=CRS("+init=epsg:32634")
                              )
```

## Caluclate density using graph methods

```{r}
plot(sites_pp)
plot(sites_vor, col = "red", add=TRUE)
```

## Caluclate density using graph methods {.columns-2}

What's wrong here?!

```{r message=FALSE, fig.height=5, fig.width=5}
plot(sites_pp, pch = 19)
points(lec, col="red")

library(plotrix)
draw.circle(x = lec@coords[,1],
            y = lec@coords[,2],
            radius = sites_vor$radius,
            border = "gray")
```

## Interpolation

We're lazy...instead of creating a raster we use one that is "already there":
load SRTM scene, reproject, crop, change to SpatialGridDataFrame

```{r message=FALSE}
library(raster)
srtm <- raster("data/srtm_41_03.tif")
srtm <- projectRaster(srtm, res=90, crs=CRS("+init=epsg:32634"))
srtm <- crop(x = srtm, y = extent(sites)+20000)
srtm <- aggregate(x = srtm, fact = 9)
library(maptools)
srtm <- as(object = srtm,
           Class = "SpatialGridDataFrame"
           )
str(srtm)
##image(srtm)
##points(sites, pch=19, cex=.5)
```

## Interpolation - Inverse Distance Weighting

```{r message=FALSE}
library(gstat)

lec_gstat_p2 <- gstat(formula = lec@data$rad ~ 1,
                      locations = lec,
                      set = list(idp = 2)
                      )
lec_gstat_p05 <- gstat(formula = lec@data$rad ~ 1,
                       locations = lec,
                       set = list(idp = .5)
                       )
lec_idw2 <- predict(object = lec_gstat_p2,
                    newdata = srtm)
lec_idw05 <- predict(object = lec_gstat_p05,
                     newdata = srtm)
```

## Interpolation - Inverse Distance Weighting {.columns-2}

```{r fig.height=5, fig.width=5, echo=FALSE}
plot(raster(lec_idw05))
points(sites_pp)

plot(raster(lec_idw2))
points(sites_pp) 
```

## Interpolation - Kriging

**very** superficial

```{r}
library(gstat)

plot(variogram(lec$rad ~ 1, lec, cloud = TRUE))
```

## Interpolation - Kriging

**very** superficial

```{r}
library(gstat)

plot(variogram(lec$rad ~ 1, lec))
```

## Interpolation - Kriging

**very** superficial

```{r}
library(gstat)

plot(variogram(lec$rad ~ 1, lec, alpha = c(0,45,90,135)))
```

## Interpolation - Kriging {.columns-2}

**very** superficial

```{r fig.height=5, fig.width=5, echo=FALSE}
#vt <- variogram(lec$rad ~ 1, lec)
plot(variogram(lec$rad ~ 1, lec))
show.vgms()
```

## Interpolation - Kriging

**very** superficial

```{r}
vt <- variogram(lec$rad ~ 1, lec)
v_fit <- fit.variogram(vt,
                       vgm(nugget = 3e+07,
                           model = "Gau",
                           psill = 3e+08, #355572513
                           range = 180000)
                       )
```

## Interpolation - Kriging

**very** superficial

```{r}
plot(vt,v_fit)
```

## Interpolation - Kriging

**very** superficial

```{r}
lec_kri <- krige(formula = lec$rad ~ 1,
                 location = lec,
                 newdata = srtm,
                 model = v_fit
                 )
```

## Interpolation - Kriging

**very** superficial

```{r}
plot(raster(lec_kri),
     main="Kriging using Gaussian fit"
     )
points(sites,pch=20,cex=.4)
```

## Interpolation - Inverse Distance Weighting vs. Kriging {.columns-2}

```{r fig.height=5, fig.width=5, echo=FALSE}
plot(raster(lec_idw05))
points(sites_pp)

plot(raster(lec_kri))
points(sites_pp) 
```
